import numpy as np
import os

TOLERANCE = 1e-6

def load_data(filepath):
    """Reads a text file with one float per line and returns a numpy array."""
    if not os.path.exists(filepath):
        raise FileNotFoundError(f"File not found: {filepath}")
    return np.loadtxt(filepath, dtype=np.float32)

def compare_files(file_cpp, file_py, label):
    """Loads data from two files and compares them."""
    print(f"\n--- Comparing {label} ---")
    try:
        data_cpp = load_data(file_cpp)
        data_py = load_data(file_py)

        len_cpp = len(data_cpp)
        len_py = len(data_py)

        if len_cpp != len_py:
            print(f"Length mismatch: C++ ({len_cpp}), Python ({len_py})")
            # Compare up to the length of the shorter array
            min_len = min(len_cpp, len_py)
            if min_len == 0:
                print("One or both files are empty. Cannot compare elements.")
                return
            print(f"Comparing first {min_len} elements...")
            data_cpp = data_cpp[:min_len]
            data_py = data_py[:min_len]
        else:
            print(f"Length match: {len_cpp} elements")

        if len(data_cpp) == 0: # Should be covered by min_len == 0 already
            print("No data to compare after length adjustment.")
            return

        abs_diff = np.abs(data_cpp - data_py)
        max_abs_diff = np.max(abs_diff)
        mean_abs_diff = np.mean(abs_diff)
        mismatches_count = np.sum(abs_diff > TOLERANCE)

        print(f"Max absolute difference:  {max_abs_diff:.8e}")
        print(f"Mean absolute difference: {mean_abs_diff:.8e}")
        print(f"Elements with difference > {TOLERANCE:.0e}: {mismatches_count} / {len(abs_diff)}")

    except FileNotFoundError as e:
        print(str(e))
    except Exception as e:
        print(f"An error occurred during comparison for {label}: {e}")

def main():
    print("Comparing outputs of C++ and Python tests...")

    file_pairs = [
        ("cpp_qmf_subband_0.txt", "py_qmf_subband_0.txt", "QMF Subband 0 (Low)"),
        ("cpp_qmf_subband_1.txt", "py_qmf_subband_1.txt", "QMF Subband 1 (Mid)"),
        ("cpp_qmf_subband_2.txt", "py_qmf_subband_2.txt", "QMF Subband 2 (High)"),

        ("cpp_mdct_coeffs_0.txt", "py_mdct_coeffs_0.txt", "MDCT Coeffs 0 (Low)"),
        ("cpp_mdct_coeffs_1.txt", "py_mdct_coeffs_1.txt", "MDCT Coeffs 1 (Mid)"),
        ("cpp_mdct_coeffs_2.txt", "py_mdct_coeffs_2.txt", "MDCT Coeffs 2 (High)"),

        ("cpp_imdct_output_0.txt", "py_imdct_output_0.txt", "IMDCT Output 0 (Low)"),
        ("cpp_imdct_output_1.txt", "py_imdct_output_1.txt", "IMDCT Output 1 (Mid)"),
        ("cpp_imdct_output_2.txt", "py_imdct_output_2.txt", "IMDCT Output 2 (High)"),

        ("cpp_reconstructed_output.txt", "py_reconstructed_output.txt", "Reconstructed Output")
    ]

    # Also compare the initial input to ensure it's identical for both tests
    # (Though python loads the C++ generated one)
    if os.path.exists("cpp_input_samples.txt") and os.path.exists("py_input_samples.txt"):
         # py_input_samples.txt is not generated by python_test.py currently
         # For now, just note that python uses cpp_input_samples.txt
        pass
    elif os.path.exists("cpp_input_samples.txt"):
        print("\nNote: Python test directly uses 'cpp_input_samples.txt'.")


    for cpp_file, py_file, label in file_pairs:
        compare_files(cpp_file, py_file, label)

    print("\nComparison finished.")

if __name__ == "__main__":
    main()
