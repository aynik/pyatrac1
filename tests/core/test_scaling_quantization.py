import pytest
from typing import List

from pyatrac1.core.codec_data import (
    Atrac1CodecData,
)  # ScaledBlock is used internally by TScaler
from pyatrac1.core.scaling_quantization import (
    TScaler,
    quantize_mantissas,
    _round_half_away_from_zero,
    BitstreamSignedValues,
)
# ScaleTable is generated and accessed via Atrac1CodecData instance


@pytest.fixture
def codec_data_fixture() -> Atrac1CodecData:
    """Provides an Atrac1CodecData instance with a predefined scale table."""
    data = Atrac1CodecData()
    # Use a small, predictable scale table for most tests
    # Original formula: pow(2.0, (i / 3.0 - 21.0))
    # For testing, let's use a simpler one, or a subset of the real one.
    # Using a small section of the real table for more realistic behavior.
    # Let's pick indices around where 0.5 and 1.0 would be.
    # ScaleTable[63] = 1.0
    # ScaleTable[54] = pow(2.0, (54/3.0 - 21.0)) = pow(2.0, 18-21) = pow(2.0, -3) = 0.125
    # ScaleTable[57] = pow(2.0, (57/3.0 - 21.0)) = pow(2.0, 19-21) = pow(2.0, -2) = 0.25
    # ScaleTable[60] = pow(2.0, (60/3.0 - 21.0)) = pow(2.0, 20-21) = pow(2.0, -1) = 0.5
    # ScaleTable[63] = pow(2.0, (63/3.0 - 21.0)) = pow(2.0, 21-21) = pow(2.0, 0) = 1.0
    # ScaleTable[66] = pow(2.0, (66/3.0 - 21.0)) = pow(2.0, 22-21) = pow(2.0, 1) = 2.0
    # Let's use a table that includes these points and some in between.
    # For simplicity in tests, let's define a small custom table.
    data.scale_table = [0.125, 0.25, 0.375, 0.5, 0.75, 1.0, 1.5, 2.0]
    # Indices:          0      1      2      3      4     5      6     7
    return data


@pytest.fixture
def full_scale_table_codec_data() -> Atrac1CodecData:
    """Provides an Atrac1CodecData instance with the full scale table."""
    data = Atrac1CodecData()
    # data.scale_table is already generated by Atrac1CodecData constructor
    return data


class TestTScaler:
    def test_scale_empty_coeffs(self, codec_data_fixture):
        scaler = TScaler(codec_data_fixture)
        spectral_coeffs: List[float] = []
        result = scaler.scale(spectral_coeffs)
        assert result.scale_factor_index == 0
        assert result.values == []
        assert result.max_energy == 0.0

    def test_scale_all_zeros_coeffs(self, codec_data_fixture):
        scaler = TScaler(codec_data_fixture)
        spectral_coeffs = [0.0, 0.0, 0.0]
        result = scaler.scale(spectral_coeffs)
        assert result.scale_factor_index == 0
        assert result.values == [0.0, 0.0, 0.0]
        assert result.max_energy == 0.0

    def test_scale_normal_case(self, codec_data_fixture):
        scaler = TScaler(codec_data_fixture)
        # max_abs_spec = 0.4, codec_data_fixture.scale_table[3] = 0.5 is the smallest >= 0.4
        spectral_coeffs = [0.1, -0.4, 0.2]
        expected_scale_factor_index = 3  # scale_table[3] = 0.5
        expected_scale_factor = codec_data_fixture.scale_table[
            expected_scale_factor_index
        ]  # 0.5

        result = scaler.scale(spectral_coeffs)

        assert result.scale_factor_index == expected_scale_factor_index
        assert result.max_energy == pytest.approx(0.4)
        expected_scaled_values = [
            0.1 / expected_scale_factor,  # 0.1 / 0.5 = 0.2
            -0.4 / expected_scale_factor,  # -0.4 / 0.5 = -0.8
            0.2 / expected_scale_factor,  # 0.2 / 0.5 = 0.4
        ]
        for res_val, exp_val in zip(result.values, expected_scaled_values):
            assert res_val == pytest.approx(exp_val)

    def test_scale_max_abs_spec_smaller_than_table_min(self, codec_data_fixture):
        scaler = TScaler(codec_data_fixture)
        # codec_data_fixture.scale_table[0] = 0.125
        spectral_coeffs = [0.01, -0.05]
        # max_abs_spec = 0.05. Smallest factor >= 0.05 is 0.125 (index 0)
        expected_scale_factor_index = 0
        expected_scale_factor = codec_data_fixture.scale_table[
            expected_scale_factor_index
        ]

        result = scaler.scale(spectral_coeffs)
        assert result.scale_factor_index == expected_scale_factor_index
        assert result.max_energy == pytest.approx(0.05)
        expected_scaled_values = [
            0.01 / expected_scale_factor,
            -0.05 / expected_scale_factor,
        ]
        for res_val, exp_val in zip(result.values, expected_scaled_values):
            assert res_val == pytest.approx(exp_val)

    def test_scale_max_abs_spec_larger_than_table_max(self, codec_data_fixture):
        scaler = TScaler(codec_data_fixture)
        # codec_data_fixture.scale_table[-1] = 2.0
        spectral_coeffs = [1.0, -3.0, 2.5]
        # max_abs_spec = 3.0. Larger than table max, so use last factor.
        expected_scale_factor_index = len(codec_data_fixture.scale_table) - 1  # index 7
        expected_scale_factor = codec_data_fixture.scale_table[
            expected_scale_factor_index
        ]  # 2.0

        result = scaler.scale(spectral_coeffs)
        assert result.scale_factor_index == expected_scale_factor_index
        assert result.max_energy == pytest.approx(3.0)

        # Values will be clamped
        expected_scaled_values = [
            1.0 / expected_scale_factor,  # 1.0 / 2.0 = 0.5
            -3.0 / expected_scale_factor,  # -3.0 / 2.0 = -1.5, clamped to -0.99999
            2.5 / expected_scale_factor,  # 2.5 / 2.0 = 1.25, clamped to 0.99999
        ]
        assert result.values[0] == pytest.approx(0.5)
        assert result.values[1] == pytest.approx(-0.99999)  # Clamped
        assert result.values[2] == pytest.approx(0.99999)  # Clamped

    def test_scale_clamping_positive(self, codec_data_fixture):
        scaler = TScaler(codec_data_fixture)
        # Choose scale_factor = 0.5 (index 3)
        # To get scaled_val > 1.0, coeff must be > 0.5
        spectral_coeffs = [0.6]  # 0.6 / 0.5 = 1.2
        result = scaler.scale(spectral_coeffs)
        assert (
            result.scale_factor_index == 4
        )  # max_abs_spec = 0.6, scale_table[3]=0.5, scale_table[4]=0.75. So index 4.
        # Logic is smallest factor >= max_abs_spec, so we need scale_table[4]=0.75 >= 0.6.
        # max_abs_spec = 0.6. scale_table[4] = 0.75. Index should be 4.
        # 0.6 / 0.75 = 0.8. No clamping.
        # Let's re-evaluate. We want coeff / chosen_scale_factor to be > 1.0
        # If chosen_scale_factor is scale_table[3] = 0.5, then coeff > 0.5.
        # For chosen_scale_factor to be 0.5 (index 3), max_abs_spec must be <= 0.5 and > 0.375
        # Let max_abs_spec = 0.5. Then chosen_scale_factor_index = 3 (0.5).
        # spectral_coeffs = [0.5, 0.51] -> max_abs_spec = 0.51. chosen_scale_factor_index = 4 (0.75)
        # 0.51 / 0.75 = 0.68. No clamping.

        # To force clamping, we need coeff / chosen_scale_factor to be extreme.
        # This happens if chosen_scale_factor is small relative to coeff,
        # but chosen_scale_factor is determined by max_abs_spec.
        # Clamping happens *after* division by chosen_scale_factor.
        # If max_abs_spec is very large, e.g., 100.0
        # chosen_scale_factor will be codec_data_fixture.scale_table[-1] = 2.0
        # spectral_coeffs = [100.0]. scaled = 100.0 / 2.0 = 50.0. Clamped to 0.99999.
        spectral_coeffs_large = [100.0]
        result_large = scaler.scale(spectral_coeffs_large)
        assert result_large.values[0] == pytest.approx(0.99999)
        assert result_large.max_energy == pytest.approx(100.0)
        assert (
            result_large.scale_factor_index == len(codec_data_fixture.scale_table) - 1
        )

    def test_scale_clamping_negative(self, codec_data_fixture):
        scaler = TScaler(codec_data_fixture)
        spectral_coeffs_large_neg = [-100.0]
        result_large_neg = scaler.scale(spectral_coeffs_large_neg)
        assert result_large_neg.values[0] == pytest.approx(-0.99999)
        assert result_large_neg.max_energy == pytest.approx(100.0)  # max_abs_spec
        assert (
            result_large_neg.scale_factor_index
            == len(codec_data_fixture.scale_table) - 1
        )

    def test_scale_with_full_scale_table(self, full_scale_table_codec_data):
        scaler = TScaler(full_scale_table_codec_data)
        # Test with a value that should pick a specific index from the full table
        # ScaleTable[60] = 0.5
        # ScaleTable[61] = pow(2.0, (61/3.0 - 21.0)) = pow(2.0, (20.333 - 21)) = pow(2.0, -0.666) approx 0.6299
        spectral_coeffs = [0.55]  # max_abs_spec = 0.55
        # We need smallest scale_table[i] >= 0.55. This should be scale_table[61].

        # Find expected index manually for verification
        expected_idx = -1
        for i, factor_val in enumerate(full_scale_table_codec_data.scale_table):
            if factor_val >= 0.55:
                expected_idx = i
                break

        result = scaler.scale(spectral_coeffs)
        assert result.scale_factor_index == expected_idx
        assert result.max_energy == pytest.approx(0.55)
        expected_scaled_val = (
            0.55 / full_scale_table_codec_data.scale_table[expected_idx]
        )
        # Clamp if necessary, though unlikely here
        if expected_scaled_val >= 1.0:
            expected_scaled_val = 0.99999
        if expected_scaled_val <= -1.0:
            expected_scaled_val = -0.99999
        assert result.values[0] == pytest.approx(expected_scaled_val)


class TestQuantizeMantissas:
    def test_quantize_word_length_zero(self):
        scaled_values = [0.1, 0.5, -0.3]
        mantissas, orig_e, quant_e = quantize_mantissas(scaled_values, 0)
        assert mantissas == [0, 0, 0]
        assert orig_e == 0.0  # word_length == 0 implies no processing of energy
        assert quant_e == 0.0

    def test_quantize_word_length_one(self):
        scaled_values = [0.1, -0.001, 0.0, -0.5, 0.99]
        # For word_length 1: val < 0 -> -1, else 0
        expected_mantissas = [0, -1, 0, -1, 0]
        mantissas, orig_e, quant_e = quantize_mantissas(scaled_values, 1)

        assert mantissas == expected_mantissas

        expected_orig_e = sum(x * x for x in scaled_values)
        assert orig_e == pytest.approx(expected_orig_e)

        # Dequantized values for energy: 0, -1, 0, -1, 0
        expected_quant_e = (
            (0 * 0) + (-1 * -1) + (0 * 0) + (-1 * -1) + (0 * 0)
        )  # 1 + 1 = 2
        assert quant_e == pytest.approx(2.0)

    @pytest.mark.parametrize(
        "val, expected",
        [
            (2.0, 2),
            (2.5, 3),
            (2.9, 3),
            (3.0, 3),
            (-2.0, -2),
            (-2.5, -3),
            (-2.9, -3),
            (-3.0, -3),
            (0.0, 0),
            (0.4, 0),
            (-0.4, 0),
            (0.5, 1),
            (-0.5, -1),
        ],
    )
    def test_round_half_away_from_zero(self, val, expected):
        assert _round_half_away_from_zero(val) == expected

    def test_quantize_no_energy_adjustment(self):
        # word_length = 4. max_quant_val = (1 << 3) - 1 = 7.
        # Range: [-7, 7]
        word_length = 4
        max_q_val = (1 << (word_length - 1)) - 1  # 7

        # scaled_value * max_q_val -> round -> clamp
        # 0.9 * 7 = 6.3 -> 6
        # 0.99 * 7 = 6.93 -> 7
        # 1.0 * 7 = 7.0 -> 7 (actually scaled values are < 1.0, e.g. 0.99999)
        # 0.99999 * 7 = 6.99993 -> 7
        # -0.99999 * 7 = -6.99993 -> -7
        # 0.5 / 7 = 0.0714... scaled_val = 0.0714.  0.0714 * 7 = 0.5 -> 1
        # 0.4 / 7 = 0.0571... scaled_val = 0.0571.  0.0571 * 7 = 0.4 -> 0
        scaled_values = [0.99999, -0.99999, 0.0714, 0.0571, 0.5]  # approx values
        # Corresponding values to be multiplied by max_q_val:
        # 0.99999 * 7 = 6.99993 -> round(7) = 7
        # -0.99999 * 7 = -6.99993 -> round(-7) = -7
        # 0.0714 * 7 = 0.4998 -> round(0) = 0 (if 0.0714 is slightly less, e.g. 0.071428 * 7 = 0.499996 -> 0)
        # Let's use values that give clear rounding:
        # 0.5/7 = 0.07142857...
        # (0.5/max_q_val) -> 0.5 -> 1
        # (3.5/max_q_val) -> 3.5 -> 4
        # (-3.5/max_q_val) -> -3.5 -> -4
        scaled_values_for_test = [
            0.9,  # 0.9 * 7 = 6.3 -> 6
            -0.9,  # -0.9 * 7 = -6.3 -> -6
            3.5 / max_q_val,  # 3.5 -> 4
            -3.5 / max_q_val,  # -3.5 -> -4
            (max_q_val + 1.0) / max_q_val,  # >1, e.g. 8/7=1.14... -> 8 -> clamped to 7
            -(max_q_val + 1.0)
            / max_q_val,  # <-1, e.g. -8/7=-1.14... -> -8 -> clamped to -7
        ]
        # Clamp input scaled_values as TScaler would
        clamped_scaled_values = [
            max(-0.99999, min(x, 0.99999)) for x in scaled_values_for_test
        ]

        expected_mantissas = [
            _round_half_away_from_zero(clamped_scaled_values[0] * max_q_val),  # 6
            _round_half_away_from_zero(clamped_scaled_values[1] * max_q_val),  # -6
            _round_half_away_from_zero(clamped_scaled_values[2] * max_q_val),  # 4
            _round_half_away_from_zero(clamped_scaled_values[3] * max_q_val),  # -4
            max_q_val,  # Clamped from 8
            -max_q_val,  # Clamped from -8
        ]

        mantissas, orig_e, quant_e = quantize_mantissas(
            clamped_scaled_values, word_length, perform_energy_adjustment=False
        )
        assert mantissas == expected_mantissas

        expected_orig_e = sum(x * x for x in clamped_scaled_values)
        assert orig_e == pytest.approx(expected_orig_e)

        dequant_factor = 1.0 / max_q_val
        expected_quant_e = sum((m * dequant_factor) ** 2 for m in expected_mantissas)
        assert quant_e == pytest.approx(expected_quant_e)

    def test_quantize_energy_adjustment_simple_case(self):
        # word_length = 3. max_quant_val = (1 << 2) - 1 = 3. Range [-3, 3]
        word_length = 3
        max_q_val = (1 << (word_length - 1)) - 1  # 3

        # Example from a similar codec: scaled = 0.8, max_q = 3.
        # scaled * max_q = 0.8 * 3 = 2.4. Initial mantissa = round(2.4) = 2.
        # Original energy contrib: 0.8^2 = 0.64
        # Quantized energy contrib (mantissa 2): (2/3)^2 = (0.666)^2 = 0.444
        # Alternative mantissa: ceil(2.4) = 3.
        # Quantized energy contrib (mantissa 3): (3/3)^2 = 1^2 = 1.0
        # Error for m=2: |0.444 - 0.64| = 0.196
        # Error for m=3: |1.0 - 0.64| = 0.36
        # So, m=2 should be kept if this was the only value.

        # Let's try a case where adjustment helps.
        # scaled_values = [0.8, 0.1]
        # s1 = 0.8 -> m1_init = round(0.8*3=2.4) = 2.  E_orig1 = 0.64. E_quant1_m2 = (2/3)^2 = 0.444. E_quant1_m3 = (3/3)^2 = 1.0
        # s2 = 0.1 -> m2_init = round(0.1*3=0.3) = 0.  E_orig2 = 0.01. E_quant2_m0 = 0.    E_quant2_m1 = (1/3)^2 = 0.111
        # Initial mantissas: [2, 0]
        # Total E_orig = 0.64 + 0.01 = 0.65
        # Total E_quant_init = 0.444 + 0 = 0.444.  Error = |0.444 - 0.65| = 0.206

        # Try flipping m1 (2 -> 3): E_quant = 1.0 + 0 = 1.0. Error = |1.0 - 0.65| = 0.35 (worse)
        # Try flipping m2 (0 -> 1): E_quant = 0.444 + 0.111 = 0.555. Error = |0.555 - 0.65| = 0.095 (better!)
        # So, mantissas should become [2, 1]

        scaled_values = [0.8, 0.1]
        expected_mantissas_after_ea = [2, 1]

        mantissas, orig_e, quant_e = quantize_mantissas(
            scaled_values, word_length, perform_energy_adjustment=True
        )

        assert mantissas == expected_mantissas_after_ea

        expected_orig_e = sum(x * x for x in scaled_values)
        assert orig_e == pytest.approx(expected_orig_e)

        dequant_factor = 1.0 / max_q_val
        expected_quant_e_final = sum(
            (m * dequant_factor) ** 2 for m in expected_mantissas_after_ea
        )
        assert quant_e == pytest.approx(expected_quant_e_final)

        # Check that the error was reduced
        initial_mantissas = [
            _round_half_away_from_zero(sv * max_q_val) for sv in scaled_values
        ]
        initial_quant_e = sum((m * dequant_factor) ** 2 for m in initial_mantissas)
        error_initial = abs(initial_quant_e - expected_orig_e)
        error_final = abs(expected_quant_e_final - expected_orig_e)
        assert error_final < error_initial

    def test_quantize_energy_adjustment_converges(self):
        # A slightly more complex case to ensure loop terminates
        word_length = 4  # max_q_val = 7
        scaled_values = [0.23, 0.55, 0.81, -0.33, -0.67]

        # We don't need to predict the exact outcome, just that it runs
        # and produces valid results.
        mantissas, orig_e, quant_e = quantize_mantissas(
            scaled_values, word_length, perform_energy_adjustment=True
        )

        assert len(mantissas) == len(scaled_values)
        max_q_val = (1 << (word_length - 1)) - 1
        for m in mantissas:
            assert -max_q_val <= m <= max_q_val

        expected_orig_e = sum(x * x for x in scaled_values)
        assert orig_e == pytest.approx(expected_orig_e)
        # Quantized energy should be somewhat close to original energy
        assert quant_e == pytest.approx(
            expected_orig_e, rel=0.5
        )  # Allow some deviation

    def test_quantize_energy_adjustment_exact_match_no_change(self):
        word_length = 3  # max_q_val = 3
        # Choose scaled values that quantize perfectly
        # e.g., 1/3, 2/3.  1/3 * 3 = 1. 2/3 * 3 = 2.
        scaled_values = [1.0 / 3.0, 2.0 / 3.0]
        # Initial mantissas: [1, 2]
        expected_mantissas = [1, 2]

        mantissas, orig_e, quant_e = quantize_mantissas(
            scaled_values, word_length, perform_energy_adjustment=True
        )
        assert mantissas == expected_mantissas

        expected_orig_e = sum(x * x for x in scaled_values)
        dequant_factor = 1.0 / 3.0
        expected_quant_e = sum((m * dequant_factor) ** 2 for m in expected_mantissas)

        assert orig_e == pytest.approx(expected_orig_e)
        assert quant_e == pytest.approx(expected_quant_e)
        assert quant_e == pytest.approx(expected_orig_e)  # Should be very close


class TestBitstreamSignedValues:
    @pytest.mark.parametrize(
        "value, num_bits, expected_unsigned",
        [
            # Positive values
            (0, 1, 0),
            (0, 4, 0),
            (1, 4, 1),
            (7, 4, 7),  # Max positive for 4 bits (signed) is 7 (0111)
            (15, 5, 15),  # Max positive for 5 bits (signed) is 15 (01111)
            # Negative values
            (-1, 1, 1),  # -1 (signed 1-bit) is 1 (unsigned)
            (-1, 4, 15),  # -1 (..1111) & 0xF = 15 (1111)
            (-8, 4, 8),  # -8 (..1000) & 0xF = 8 (1000) Min negative for 4 bits
            (-7, 4, 9),  # -7 (..1001) & 0xF = 9 (1001)
            (-16, 5, 16),  # -16 (..10000) & 0x1F = 16 (10000) Min negative for 5 bits
            # Values that would be clamped if they were too large for signed representation,
            # but encode_signed just takes the lower bits.
            (
                8,
                4,
                8,
            ),  # 8 (0b1000) - this is -8 in 4-bit signed. encode_signed takes lower bits.
            (10, 4, 10),  # 10 (0b1010)
        ],
    )
    def test_encode_signed(self, value, num_bits, expected_unsigned):
        assert BitstreamSignedValues.encode_signed(value, num_bits) == expected_unsigned

    def test_encode_signed_zero_bits(self):
        assert BitstreamSignedValues.encode_signed(5, 0) == 0
        assert BitstreamSignedValues.encode_signed(-5, 0) == 0

    @pytest.mark.parametrize(
        "unsigned_value, num_bits, expected_signed",
        [
            # Positive values
            (0, 1, 0),
            (0, 4, 0),
            (1, 4, 1),
            (7, 4, 7),  # 7 (0111) -> +7
            (15, 5, 15),  # 15 (01111) -> +15
            # Negative values
            (1, 1, -1),  # 1 (1) with num_bits=1 -> -1
            (15, 4, -1),  # 15 (1111) with num_bits=4 -> -1
            (8, 4, -8),  # 8 (1000) with num_bits=4 -> -8
            (9, 4, -7),  # 9 (1001) with num_bits=4 -> -7
            (16, 5, -16),  # 16 (10000) with num_bits=5 -> -16
        ],
    )
    def test_decode_signed(self, unsigned_value, num_bits, expected_signed):
        assert (
            BitstreamSignedValues.decode_signed(unsigned_value, num_bits)
            == expected_signed
        )

    def test_decode_signed_zero_bits(self):
        assert BitstreamSignedValues.decode_signed(0, 0) == 0
        # Non-zero unsigned_value with 0 bits should ideally not happen or be handled by reader
        # Current impl: if num_bits <=0, returns 0.
        assert BitstreamSignedValues.decode_signed(1, 0) == 0

    @pytest.mark.parametrize("num_bits", [1, 2, 3, 4, 5, 8, 16])
    def test_encode_decode_signed_roundtrip(self, num_bits):
        if num_bits == 0:
            pytest.skip("num_bits=0 handled separately")

        min_val = -(1 << (num_bits - 1))
        max_val = (1 << (num_bits - 1)) - 1

        test_values = [min_val, max_val, 0]
        if min_val + 1 <= max_val:
            test_values.append(min_val + 1)
        if max_val - 1 >= min_val:
            test_values.append(max_val - 1)
        if num_bits > 2:  # Add some mid-range values
            test_values.append(min_val // 2)
            test_values.append(max_val // 2)

        for val in set(test_values):  # Use set to remove duplicates for small num_bits
            encoded = BitstreamSignedValues.encode_signed(val, num_bits)
            decoded = BitstreamSignedValues.decode_signed(encoded, num_bits)
            assert decoded == val, (
                f"Failed for num_bits={num_bits}, value={val}, encoded={encoded}"
            )

    def test_bitstreamsignedvalues_edge_cases_num_bits_1(self):
        # Encode
        assert BitstreamSignedValues.encode_signed(0, 1) == 0  # 0b0
        assert BitstreamSignedValues.encode_signed(-1, 1) == 1  # 0b1
        # Decode
        assert BitstreamSignedValues.decode_signed(0, 1) == 0
        assert BitstreamSignedValues.decode_signed(1, 1) == -1


class TestScalingQuantizationEdgeCases:
    """Additional tests to cover edge cases and missing lines."""

    def test_tscaler_zero_scale_factor_edge_case(self):
        """Test TScaler with edge case where chosen scale factor is zero."""
        codec_data = Atrac1CodecData()
        scaler = TScaler(codec_data)
        
        # Mock the scale table to include zero at some index
        original_scale_table = scaler.codec_data.scale_table
        scaler.codec_data.scale_table = [0.0, 0.1, 0.2, 0.5, 1.0]
        
        try:
            # Create input that will result in zero scale factor selection
            # When max_abs_spec is 0, chosen_scale_factor becomes 0
            spectral_coeffs = [0.0, 0.0, 0.0]
            
            result = scaler.scale(spectral_coeffs)
            
            # All scaled values should be 0.0 when scale factor is 0 (line 67)
            assert all(val == 0.0 for val in result.values)
            assert result.scale_factor_index == 0
        finally:
            # Restore original scale table
            scaler.codec_data.scale_table = original_scale_table

    def test_bitstream_signed_values_edge_cases(self):
        """Test BitstreamSignedValues with edge cases."""
        # Test with num_bits = 0
        result = BitstreamSignedValues.encode_signed(5, 0)
        assert result == 0
        
        result = BitstreamSignedValues.decode_signed(10, 0)
        assert result == 0
        
        # Test with num_bits too large (lines 246, 285)
        with pytest.raises(ValueError, match="num_bits too large"):
            BitstreamSignedValues.encode_signed(5, 33)
            
        with pytest.raises(ValueError, match="num_bits too large"):
            BitstreamSignedValues.decode_signed(10, 33)

    def test_quantize_mantissas_energy_adjustment_continue_paths(self):
        """Test quantize_mantissas energy adjustment continue paths."""
        # This test aims to hit the continue statements on lines 180 and 186
        
        word_length = 3  # max_quant_val = 3
        max_q_val = (1 << (word_length - 1)) - 1
        
        # Create scaled values that will trigger the continue paths
        # Use extreme values to force clamping scenarios
        scaled_values = [1.5, -1.5, 0.99999, -0.99999]
        
        mantissas, _, _ = quantize_mantissas(
            scaled_values, word_length, perform_energy_adjustment=True
        )
        
        # Should still produce valid mantissas
        assert len(mantissas) == len(scaled_values)
        assert all(abs(m) <= max_q_val for m in mantissas)

    def test_quantize_mantissas_large_max_quant_val(self):
        """Test quantize_mantissas with large max_quant_val to test boundary conditions."""
        word_length = 8  # max_quant_val = 127
        scaled_values = [0.5, -0.5, 0.999, -0.999]
        
        mantissas, orig_e, quant_e = quantize_mantissas(
            scaled_values, word_length, perform_energy_adjustment=True
        )
        
        max_q_val = (1 << (word_length - 1)) - 1
        assert all(abs(m) <= max_q_val for m in mantissas)
        assert len(mantissas) == len(scaled_values)

    def test_alternative_mantissa_clamping_edge_case(self):
        """Test the specific case where alternative mantissa gets clamped to current value."""
        word_length = 2  # max_quant_val = 1, range [-1, 1]
        
        # Use values that will result in extreme mantissas where alternatives get clamped
        scaled_values = [1.0, -1.0]  # Will map to mantissas [1, -1]
        
        mantissas, _, _ = quantize_mantissas(
            scaled_values, word_length, perform_energy_adjustment=True
        )
        
        # At the boundaries, alternatives would be clamped to same values
        assert mantissas == [1, -1]
